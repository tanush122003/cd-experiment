<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experiments</title>
</head>
<body>
    <p>
<p>        SRM Institute of Science and Technology                                                        
<p>College of Engineering and Technology                                                                       
<p>School of Computing                                                                                    
<p>Department of Computing Technologies                                                                       
<p>B.Tech – Computer Science and Engineering                                                                   
<p>Regulations 2018                                                                                     
<p>18CSC304J – Compiler Design                                                                                 
<p>LAB MANUAL
<p>Prepared by
<p>Dr. K. Vijaya
<p>Dr. D. Vinod
<p>Dr. K. Anitha
<p>SRM Institute of Science and Technology
<p>College of Engineering and Technology
<p>School of Computing
<p>Department of Computing Technologies
<p>B.Tech – Computer Science and Engineering
<p>Regulations 2018
<p>18CSC304J – Compiler Design
<p>Department Vision
<p>• To become a world-class department in imparting high-quality knowledge and providing
<p>students with a unique learning and research experience in Computer Science and
<p>Engineering.
<p>Department Mission
<p>• To impart knowledge in cutting edge technologies in part with industrial standards.
<p>• To collaborate with renowned academic institutions in research and development.
<p>• To instill societal and ethical responsibilities in all professional activities.
<p>3
<p>List of Experiments
<p>S.
<p>No.
<p>Topic(s) CO PO
<p>1 Write a simple calculator program in C/C++/JAVA 1 1
<p>2 Write a program using FLEX. 1 2,5
<p>3 Implementation of scanner by specifying Regular Expressions. 1 2,5
<p>4 Write a program using BISON. 2 2,5
<p>5 Write a program for Top-Down Parsing - predictive parsing table
<p>(Removal of Left recursion/Left factoring and Compute FIRST &
<p>FOLLOW).
<p>2 2
<p>6 Write a program for Bottom-Up Parsing - SLR Parsing 3 2
<p>7 Introduction to basic Java - Programs in java 3 2
<p>8 Write a program to traverse syntax trees and perform action arithmetic
<p>operations
<p>3 2
<p>9 Write an Intermediate code generation for If/While. 4 3
<p>10 Code Generation Introduction to MIPS Assembly language- (Teach
<p>SPIM MIPS simulator).
<p>4 3
<p>11 Write a program to generate machine code for a simple statement 5 3
<p>12 Write a program to generate machine code for an indexed assignment
<p>statement
<p>5 3
<p>4
    <br>
    <br>
    <br>
<p>Ex. 1: Write a simple calculator program in C/C++/JAVA
<p>Features of the calculator:
<p>• Take input from standard input.
<p>• On each line an arithmetic expression can be given in the standard format and the
<p>calculator
<p>• must print the o/p after that.
<p>• The calculator should exit, when the user enters the Ctrl^D (eof) character.
<p>• Supported operators: +, -, *, /, ^, and ().
<p>Procedure for simple calculator:
<p>1. Read a line of input
<p>2. If input is Ctrl^D terminate the program
<p>3. If the expression is not balanced for parenthesis report error and go to step 1
<p>4. Convert the expression into post-fix notation
<p>5. Scan through the post-fix expression and push the operands into the stack in the
<p>order they appear
<p>6. When any operator is encountered pop the top two stack elements (operands) and
<p>execute the operation
<p>7. Push the result on to the stack
<p>8. Print the result and got to step 1
<p>Procedure for post-fix conversion:
<p>1. Scan the expression from left to right
<p>2. If the scanned character is operand place it in postfix expression
<p>3. If the scanned character is an operand
<p>a. If the precedence and associativity of the scanned operator is larger than the one
<p>in the stack then push it onto the stack.
<p>b. Else pop all the operators from the stack, which are greater than or equal to in
<p>precedence and place it in postfix expression and push the scanned operator into the
<p>stack. Popping should be stopped if a parenthesis is encountered.
<p>4. If the scanned character is a ‘(‘ push it into the stack
<p>5. If the scanned character is a ‘)’, pop the stack and output it until a ‘(‘ is
<p>encountered, and discard both the parenthesis.
<p>6. Repeat steps 2-5 until the infix expression is scanned.
<p>7. Once the scanning is over, pop the stack and add the operators in the postfix
<p>expression until it is not empty.
<p>8. Return the postfix expression.
<p>5
<p>Procedure for Balancing Symbols:
<p>1. Traverse the expression from left to right.
<p>a. If the current character is a starting bracket, then push it to stack
<p>b. If the current character is a closing bracket, then pop from stack and if the poppedcharacter
<p>is not matching starting bracket, return “not balanced”.
<p>2. If there is some starting bracket left in stack then return “not balanced”
<p>3. Return balanced
<p>Example run of the program:
<p>Input: 2 + 3 * 5
<p>Output: 17
<p>Input 2: (2 + 3) * 5
<p>Output 2: 25
<p>Input 3: 30 / 5 / 2
<p>Output 3: 3
<p>Input 4: 2 ^ 3 ^ 2
<p>Output 4: 64
<p>Input 5: (2 ^ 3) ^ 2
<p>Output 5: 36
<p>6
    <br>
    <br>
    <br>
<p>Ex. 2: Write a program Using FLEX
<p>Flex is a scanner generator tool for lexical analysis, which is based on finite state
<p>machine (FSM). The input is a set of regular expressions, and the output is the code to
<p>implement the scanner according to the input rules.
<p>To implement a scanner for calculator, we can write the file “cal1.l” as below:
<p>/* this is only for scanner, not link with parser yet */
<p>%{
<p>int lineNum = 0;
<p>%}
<p>%%
<p>"(" { printf("(\n"); }
<p>")" { printf(")\n"); }
<p>"+" { printf("+\n"); }
<p>"*" { printf("*\n"); }
<p>\n { lineNum++; }
<p>[ \t]+ { }
<p>[0-9]+ { printf("%s\n", yytext); }
<p>%%
<p>int yywrap() {
<p>return 1;
<p>}
<p>int main () {
<p>yylex();
<p>return 0;
<p>}
<p>Here is the Makefile used to build the scanner:
<p>p1: lex.yy.o
<p>gcc -g -o p1 lex.yy.o
<p>lex.yy.o: cal1.l
<p>flex cal1.l; gcc -g -c lex.yy.c
<p>clean:
<p>rm -f p1 *.o lex.yy.c
<p>Simple calculator program in bison
<p>//yacc file
<p>#include&lt;stdio.h&gt;
<p>int regs[26];
<p>int base;
<p>%}
<p>7
<p>%start list
<p>%union { int a; }
<p>%token DIGIT LETTER
<p>%left &#39;|&#39;
<p>%left &#39;&amp;&#39;
<p>%left &#39;+&#39; &#39;-&#39;
<p>%left &#39;*&#39; &#39;/&#39; &#39;%&#39;
<p>%left UMINUS /*supplies precedence for unary minus */
<p>%% /* beginning of rules section */
<p>list: /*empty */
<p>|
<p>list stat &#39;\n&#39;
<p>|
<p>list error &#39;\n&#39;
<p>{
<p>yyerrok;
<p>}
<p>;
<p>stat: expr
<p>{
<p>printf(&quot;%d\n&quot;,$1);
<p>}
<p>|
<p>LETTER &#39;=&#39; expr
<p>{
<p>regs[$1.a] = $3.a;
<p>};
<p>8

    <br>
    <br>
    <br>
<p>Ex. 3 : Implementation of scanner by specifying Regular Expressions
<p>Procedure:
<p>1. Place the following files in a folder minijava.html, P1.tab.h, P1.l and a sample
<p>input file
<p>(Factorial.java).
<p>2. flex P1.l
<p>3. gcc lex.yy.c -o P1
<p>4. P1
<p>5. Give = if as input
<p>Output: = number (number is symbol table id of =)
<p>if number (number is symbol table id of if)
<p>6. Fill in the code that you have been asked to include in P1.l
<p>7. flex P1.l
<p>8. gcc lex.yy.c -o P1
<p>9. P1 < Factorial.java
<p>10. All tokens generated by the parser will be placed in the output
<p>The content for minijava.html:
<p>Goal ::= MainClass ( TypeDeclaration )* <EOF>
<p>MainClass ::= "class" Identifier "{" "public" "static" "void" "main" "(" "String" "["
<p>"]" Identifier ")" "{" PrintStatement "}" "}"
<p>TypeDeclaration ::= ClassDeclaration
<p>| ClassExtendsDeclaration
<p>ClassDeclaration ::= "class" Identifier "{" ( VarDeclaration )* ( MethodDeclaration
<p>)* "}"
<p>ClassExtendsDeclaration ::= "class" Identifier "extends" Identifier "{" (
<p>VarDeclaration )*
<p>( MethodDeclaration )* "}"
<p>VarDeclaration ::= Type Identifier ";"
<p>MethodDeclaration ::= "public" Type Identifier "(" ( FormalParameterList )? ")" "{"
<p>( VarDeclaration )*
<p>( Statement )* "return" Expression ";" "}"
<p>FormalParameterList ::= FormalParameter ( FormalParameterRest )*
<p>FormalParameter ::= Type Identifier
<p>FormalParameterRest ::= "," FormalParameter
<p>Type ::= ArrayType
<p>| BooleanType
<p>| IntegerType
<p>| Identifier
<p>ArrayType ::= "int" "[" "]"
<p>BooleanType ::= "boolean"
<p>IntegerType ::= "int"
<p>Statement ::= Block
<p>9
<p>| AssignmentStatement
<p>| ArrayAssignmentStatement
<p>| IfStatement
<p>| WhileStatement
<p>| PrintStatement
<p>Block ::= "{" ( Statement )* "}"
<p>AssignmentStatement ::= Identifier "=" Expression ";"
<p>ArrayAssignmentStatement ::= Identifier "[" Expression "]" "=" Expression ";"
<p>IfStatement ::= "if" "(" Expression ")" Statement "else" Statement
<p>WhileStatement ::= "while" "(" Expression ")" Statement
<p>PrintStatement ::= "System.out.println" "(" Expression ")" ";"
<p>Expression ::= AndExpression
<p>| CompareExpression
<p>| PlusExpression
<p>| MinusExpression
<p>| TimesExpression
<p>| ArrayLookup
<p>| ArrayLength
<p>| MessageSend
<p>| PrimaryExpression
<p>AndExpression ::= PrimaryExpression "&" PrimaryExpression
<p>CompareExpression ::= PrimaryExpression "<" PrimaryExpression
<p>PlusExpression ::= PrimaryExpression "+" PrimaryExpression
<p>MinusExpression ::= PrimaryExpression "-" PrimaryExpression
<p>TimesExpression ::= PrimaryExpression "*" PrimaryExpression
<p>ArrayLookup ::= PrimaryExpression "[" PrimaryExpression "]"
<p>ArrayLength ::= PrimaryExpression "." "length"
<p>MessageSend ::= PrimaryExpression "." Identifier "(" ( ExpressionList )? ")"
<p>ExpressionList ::= Expression ( ExpressionRest )*
<p>ExpressionRest ::= "," Expression
<p>PrimaryExpression ::= IntegerLiteral
<p>| TrueLiteral
<p>| FalseLiteral
<p>| Identifier
<p>| ThisExpression
<p>| ArrayAllocationExpression
<p>| AllocationExpression
<p>| NotExpression
<p>| BracketExpression
<p>IntegerLiteral ::= <INTEGER_LITERAL>
<p>TrueLiteral ::= "true"
<p>FalseLiteral ::= "false"
<p>Identifier ::= <IDENTIFIER>
<p>ThisExpression ::= "this"
<p>10
<p>ArrayAllocationExpression ::= "new" "int" "[" Expression "]"
<p>AllocationExpression ::= "new" Identifier "(" ")"
<p>NotExpression ::= "!" Expression
<p>BracketExpression ::= "(" Expression ")"
<p>The content for P1.tab.h
<p>/* A Bison parser, made by GNU Bison 2.5. */
<p>/* Bison interface for Yacc-like parsers in C
<p>Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
<p>This program is free software: you can redistribute it and/or modify
<p>it under the terms of the GNU General Public License as published by
<p>the Free Software Foundation, either version 3 of the License, or
<p>(at your option) any later version.
<p>This program is distributed in the hope that it will be useful,
<p>but WITHOUT ANY WARRANTY; without even the implied warranty of
<p>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
<p>GNU General Public License for more details.
<p>You should have received a copy of the GNU General Public License
<p>along with this program. If not, see <http://www.gnu.org/licenses/>. */
<p>/* As a special exception, you may create a larger work that contains
<p>part or all of the Bison parser skeleton and distribute that work
<p>under terms of your choice, so long as that work isn't itself a
<p>parser generator using the skeleton or a modified version thereof
<p>as a parser skeleton. Alternatively, if you modify or redistribute
<p>the parser skeleton itself, you may (at your option) remove this
<p>special exception, which will cause the skeleton and the resulting
<p>Bison output files to be licensed under the GNU General Public
<p>License without this special exception.
<p>This special exception was added by the Free Software Foundation in
<p>version 2.2 of Bison. */
<p>/* Tokens. */
<p>#ifndef YYTOKENTYPE
<p># define YYTOKENTYPE
<p>/* Put the tokens into the symbol table, so that GDB and other debuggers
<p>know about them. */
<p>enum yytokentype {
<p>HASHDEFINE = 258,
<p>NOT = 259,
<p>CURLY_OPEN = 260,
<p>CURLY_CLOSE = 261,
<p>PAR_OPEN = 262,
<p>PAR_CLOSE = 263,
<p>11
<p>SQR_CLOSE = 264,
<p>IF = 265,
<p>WHILE = 266,
<p>CLASS = 267,
<p>PUBLIC = 268,
<p>STATIC = 269,
<p>VOID = 270,
<p>MAIN = 271,
<p>STR = 272,
<p>PRINTLN = 273,
<p>EXTENDS = 274,
<p>THIS = 275,
<p>NEW = 276,
<p>SEMI_COLON = 277,
<p>COMMA = 278,
<p>LENGTH = 279,
<p>TRUE = 280,
<p>FALSE = 281,
<p>NUMBER = 282,
<p>RET = 283,
<p>BOOL = 285,
<p>INT = 286,
<p>IDENTIFIER = 287,
<p>ADD = 288,
<p>SUB = 289,
<p>MUL = 290,
<p>DIV = 291,
<p>MOD = 292,
<p>BIT_AND = 293,
<p>LESSTHAN = 294,
<p>SQR_OPEN = 295,
<p>DOT = 296,
<p>ASSIGNMENT = 297,
<p>ELSE = 298,
<p>lab1 = 299,
<p>newlabel = 300,
<p>label = 301
<p>};
<p>#endif
<p>#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
<p>typedef union YYSTYPE
<p>{
<p>/* Line 2068 of yacc.c */
<p>#line 25 "P1.y"
<p>12
<p>char* str;
<p>/* Line 2068 of yacc.c */
<p>#line 102 "P1.tab.h"
<p>} YYSTYPE;
<p># define YYSTYPE_IS_TRIVIAL 1
<p># define yystype YYSTYPE /* obsolescent; will be withdrawn */
<p># define YYSTYPE_IS_DECLARED 1
<p>#endif
<p>extern YYSTYPE yylval;
<p>Template of the lex (P1.l) file with code for one operator and one keyword.
<p>%{
<p>#include "P1.tab.h"
<p>#include<stdio.h>
<p>#include<stdlib.h>
<p>%}
<p>%%
<p>/* Write code to ignore empty spaces and newlines. */
<p>/* Write code to ignore comments (single line and multiline). */
<p>/* Write code to scan all the operators, paranthesis etc. Example shown for
<p>assignment. */
<p>"=" {char* str=yytext;printf ("%s %d\n", str, ASSIGNMENT);}
<p>/* Write code to scan all the keywords. Example shown for if */
<p>"if" {char* str=yytext;printf ("%s %d\n", str, IF);}
<p>* Write code to scan all the punctuations. */
<p>/* Write code to scan numbers and identifiers. */
<p>/* Write code to throw error if you encounter any invalid token. */
<p>%%
<p>int main(){
<p>yylex();
<p>}
<p>int yywrap(){}
<p>The content for Factorial.java
<p>class Factorial{
<p>public static void main(String[] a){
<p>System.out.println(new Fac().ComputeFac((10)));
<p>}
<p>}
<p>class Fac { // Test
<p>public int ComputeFac(int num){
<p>int num_aux ;
<p>if (num < 2)
<p>num_aux = 1 ;
<p>else
<p>13
<p>num_aux = num * (this.ComputeFac(num-1)) ;
<p>return num_aux ;
<p>}}
<p>14

    <br>
    <br>
    <br>
<p>Ex. 4: Write a program using BISON.Simple calculator program in bison
<p>• Features of the calculator:
<p>- the calculator takes input from standard input.
<p>- As input, on each line an arithmetic expression can be given in the standard
<p>format and the calculator must print the o/p after that.
<p>- The calculator should exit, when the user enters the Ctrl^D (eof) character.
<p>- Supported operators: +, -, *, /, ^, and ().
<p>Procedure:
<p>1. Define Lexical Analysis Rules: Write lexical analysis rules using regular expressions to identify
<p>tokens like identifiers, numbers, operators, etc. Use the flex tool to generate the corresponding lexer
<p>code.
<p>2. Define Syntax Rules: Write Bison grammar rules specifying the syntax of your language.
<p>Bison uses BNF-like notation for specifying grammar rules. These rules define how
<p>different parts of the language can be combined to form valid programs.
<p>3. Handle Tokenization: In your Bison grammar file, specify how tokens generated by the
<p>lexer should be handled. This involves associating token types with grammar symbols and
<p>actions to take when certain combinations of tokens are recognized.
<p>4. Implement Semantic Actions: Define semantic actions associated with grammar rules to
<p>specify what should happen when a certain rule is recognized during parsing. Semantic
<p>actions typically involve constructing abstract syntax trees (ASTs) or executing code.
<p>5. Error Handling: Implement error handling mechanisms to detect and report syntax errors
<p>during parsing. Bison provides facilities for error recovery and reporting.
<p>6. Generate Parser Code: Use the bison tool to generate C code for the parser based on your
<p>Bison grammar file.
<p>7. Integrate Lexer and Parser: Integrate the lexer and parser code into a single program. The
<p>lexer provides tokens to the parser, which uses the Bison-generated parser code to parse the
<p>input according to the grammar rules.
<p>8. Test the Parser: Test the parser with various inputs to ensure that it correctly recognizes
<p>valid programs and detects syntax errors in invalid ones.
<p>Bison program for a calculator:
<p>1. Lexical tokens are defined using %token.
<p>2. Grammar rules are specified using the syntax lhs: rhs.
<p>3. Semantic actions are written within curly braces {} and can include C code.
<p>4. The %left directive specifies the associativity of operators.
<p>5. The yylex() function is the lexer function that provides tokens to the parser.
<p>6. The yyerror() function handles syntax errors.
<p>7. The main() function calls yyparse() to start the parsing process.
<p>15
<p>//yacc file #include&lt;stdio.h&gt;int regs[26];
<p>int base;
<p>%}
<p>%start list
<p>%union { int a; }
<p>%token DIGIT LETTER
<p>%left &#39;|&#39;
<p>%left &#39;&amp;&#39;
<p>%left &#39;+&#39; &#39;-&#39;
<p>%left &#39;*&#39; &#39;/&#39; &#39;%&#39;
<p>%left UMINUS /*supplies precedence for unary minus */
<p>%% /* beginning of rules section */
<p>list: /*empty */
<p>|
<p>list stat &#39;\n&#39;
<p>|
<p>list error &#39;\n&#39;
<p>{
<p>yyerrok;
<p>}
<p>;
<p>stat: expr
<p>{
<p>printf(&quot;%d\n&quot;,$1);
<p>}
<p>|
<p>LETTER &#39;=&#39; expr
<p>{
<p>regs[$1.a] = $3.a;
<p>}
<p>;
<p>expr: &#39;(&#39; expr &#39;)&#39;
<p>{
<p>$$ = $2;
<p>}
<p>|
<p>expr &#39;*&#39; expr
<p>{
<p>$$.a = $1.a * $3.a;
<p>}
<p>|
<p>expr &#39;/&#39; expr
<p>16
<p>{
<p>$$.a = $1.a / $3.a;
<p>}
<p>|
<p>expr &#39;%&#39; expr
<p>{
<p>$$.a = $1.a % $3.a;
<p>}
<p>|
<p>expr &#39;+&#39; expr
<p>{
<p>$$.a = $1.a + $3.a;
<p>}
<p>|
<p>expr &#39;-&#39; expr
<p>{
<p>$$.a = $1.a - $3.a;
<p>}
<p>|
<p>expr &#39;&amp;&#39; expr
<p>{
<p>$$.a = $1.a &amp; $3.a;
<p>}
<p>|
<p>expr &#39;|&#39; expr
<p>{
<p>$$.a = $1.a | $3.a;
<p>}
<p>|
<p>&#39;-&#39; expr %prec UMINUS
<p>{
<p>$$.a = -$2.a;
<p>}
<p>|
<p>LETTER
<p>{
<p>$$.a = regs[$1.a];
<p>}
<p>|
<p>number
<p>;
<p>number: DIGIT
<p>{
<p>17
<p>$$ = $1;
<p>base = ($1.a==0) ? 8 : 10;
<p>} |
<p>number DIGIT
<p>{
<p>$$.a = base * $1.a + $2.a;
<p>}
<p>;
<p>%%
<p>main()
<p>{
<p>return(yyparse());
<p>}
<p>yyerror(s)
<p>char *s;
<p>{
<p>fprintf(stderr, &quot;%s\n&quot;,s);
<p>}
<p>yywrap()
<p>{
<p>return(1);
<p>}
<p>LEX FILE
<p>#include &lt;stdio.h&gt;
<p>#include &quot;y.tab.h&quot;
<p>int c;
<p>%}
<p>%%
<p>&quot; &quot; ;
<p>[a-z] {
<p>c = yytext[0];
<p>yylval.a = c - &#39;a&#39;;
<p>return(LETTER);
<p>}
<p>[0-9] {
<p>c = yytext[0];
<p>yylval.a = c - &#39;0&#39;;
<p>return(DIGIT);
<p>}
<p>[^a-z0-9\b] {
<p>c = yytext[0];
<p>return(c);
<p>18
<p>}
<p>%%
<p>1) Create the calc.yacc file
<p>2) Create the calc.lex file
<p>3) Run the following commands:
<p>yacc -d calc.yacc
<p>lex -d calc.lex
<p>cc y.tab.c lex.yy.c
<p>./a.out
<p>OUTPUT:
<p>5+4
<p>9
<p>19

    <br>
    <br>
    <br>
<p>Ex. 5. Write a program for Top-Down Parsing - predictive parsing table (Removalof Left
<p>recursion/Left factoring and Compute FIRST & FOLLOW)
<p>Procedure
<p>Input: Grammar G
<p>Output: Parsing table
<p>1. Remove left recursion from the grammar G.
<p>a. For each non-terminal A in G, do the following:
<p>i. If there exists a production A -> Aα | β,
<p>where β is not starting with A, split it into:
<p>A -> βA'
<p>A' -> αA' | ε (epsilon), where ε represents the empty string.
<p>ii. If A -> β1 | β2 | ... | βn are the productions of A after step 1,
<p>remove βi if βi starts with A.
<p>2. Compute FIRST sets for each non-terminal and terminal symbol in the
<p>grammarG.
<p>a. Initialize FIRST set for each terminal as itself.
<p>b. For each non-terminal A in G, initialize FIRST(A) as an empty set.
<p>c. Repeat until no changes in FIRST sets:
<p>i. For each production A -> α, do the following:
<p>- If α is terminal or ε, add α to FIRST(A).
<p>- If α is non-terminal, add all symbols from FIRST(α) to FIRST(A),
<p>except ε.
<p>- If ε is in FIRST(α), continue to the next symbol.
<p>3. Compute FOLLOW sets for each non-terminal in the grammar G.
<p>a. Initialize FOLLOW set for the start symbol S as { $ }, where $ is the end
<p>marker.
<p>b. Repeat until no changes in FOLLOW sets:
<p>i. For each production A -> αBβ, where B is a non-terminal:
<p>- Add all symbols from FIRST(β) to FOLLOW(B), except ε.
<p>- If β is ε or the symbols in β derive ε, add all symbols from FOLLOW(A) to FOLLOW
<p>(B)
<p>20
<p>4. Construct the parsing table.
<p>a. Initialize parsing table M with empty entries.
<p>b. For each production A -> α in G, do the following:
<p>i. For each terminal a in FIRST(α), add A -> α to M[A, a].
<p>- If α derives ε, add A -> α to M[A, b] for each terminal b in FOLLOW(A).
<p>ii. If ε is in FIRST(α), for each terminal b in FOLLOW(A),
<p>add A -> α to M[A, b].
<p>5. Return the parsing table M.
<p>Example:
<p>Remove left recursion from the grammar G
<p>public static List<String> removeLeftRecursion(List<String> grammar) {
<p>List<String> newGrammar = new ArrayList<>();
<p>// Iterate over each non-terminal in the grammar
<p>for (String production : grammar) {
<p>String[] parts = production.split("->");
<p>String nonTerminal = parts[0].trim();
<p>String[] alternatives = parts[1].trim().split("\\|");
<p>List<String> withRecursion = new ArrayList<>();
<p>List<String> withoutRecursion = new ArrayList<>();
<p>// Separate productions with and without left recursion
<p>for (String alt : alternatives) {
<p>if (alt.trim().startsWith(nonTerminal)) {
<p>withRecursion.add(alt.trim().substring(nonTerminal.length()).trim() + "
<p>" + nonTerminal + "'");
<p>} else {
<p>withoutRecursion.add(alt.trim() + " " + nonTerminal + "'");
<p>}
<p>}
<p>Removal of left factoring
<p>public static List<String> leftFactor(List<String> grammar) {
<p>List<String> newGrammar = new ArrayList<>();
<p>// Iterate over each non-terminal in the grammar
<p>for (String production : grammar) {
<p>String[] parts = production.split("->");
<p>String nonTerminal = parts[0].trim();
<p>21
<p>String[] alternatives = parts[1].trim().split("\\|");
<p>// Find the common prefix among alternatives
<p>String commonPrefix = findCommonPrefix(alternatives);
<p>// If there is a common prefix, perform left factoring
<p>if (!commonPrefix.isEmpty()) {
<p>StringBuilder sb = new StringBuilder();
<p>sb.append(nonTerminal).append(" -> ").append(commonPrefix).append("
<p>").append(nonTerminal).append("'");
<p>newGrammar.add(sb.toString());
<p>StringBuilder sb2 = new StringBuilder();
<p>for (String alt : alternatives) {
<p>if (alt.startsWith(commonPrefix)) {
<p>sb2.append(alt.substring(commonPrefix.length()).trim());
<p>sb2.append(" | ");
<p>}
<p>}
<p>sb2.append("ε");
<p>newGrammar.add(nonTerminal + "' -> " + sb2.toString());
<p>} else {
<p>// If no common prefix, keep the production as is
<p>newGrammar.add(production);
<p>}
<p>}
<p>return newGrammar;
<p>}
<p>Parse table creation
<p>public class TopDownParser {
<p>public static void main(String[] args) {
<p>// Example grammar: S -> A, A -> aA | ε
<p>Map<String, Set<String>> firstSets = new HashMap<>();
<p>Map<String, Set<String>> followSets = new HashMap<>();
<p>// Construct FIRST sets
<p>firstSets.put("S", new HashSet<>());
<p>firstSets.put("A", new HashSet<>());
<p>firstSets.get("S").add("a");
<p>firstSets.get("A").add("a");
<p>firstSets.get("A").add("ε");
<p>22
<p>// Construct FOLLOW sets
<p>followSets.put("S", new HashSet<>());
<p>followSets.put("A", new HashSet<>());
<p>followSets.get("S").add("$");
<p>followSets.get("A").add("$");
<p>followSets.get("A").add("a");
<p>// Construct parse table
<p>Map<String, Map<String, String>> parseTable = new HashMap<>();
<p>parseTable.put("S", new HashMap<>());
<p>parseTable.put("A", new HashMap<>());
<p>parseTable.get("S").put("a", "A");
<p>parseTable.get("A").put("a", "aA");
<p>parseTable.get("A").put("$", "ε");
<p>// Print FIRST sets
<p>System.out.println("FIRST sets:");
<p>for (Map.Entry<String, Set<String>> entry : firstSets.entrySet()) {
<p>System.out.println(entry.getKey() + ": " + entry.getValue());
<p>}
<p>// Print FOLLOW sets
<p>System.out.println("\nFOLLOW sets:");
<p>for (Map.Entry<String, Set<String>> entry : followSets.entrySet()) {
<p>System.out.println(entry.getKey() + ": " + entry.getValue());
<p>}
<p>// Print parse table
<p>System.out.println("\nParse Table:");
<p>for (Map.Entry<String, Map<String, String>> entry : parseTable.entrySet()) {
<p>String nonTerminal = entry.getKey();
<p>Map<String, String> actions = entry.getValue();
<p>System.out.println("Non-Terminal: " + nonTerminal);
<p>System.out.println("Actions: " + actions);
<p>}
<p>}
<p>}
<p>23
<p>EXPRESSION GRAMMAR
<p>E->E+T
<p>E->T
<p>T->T*F
<p>T->F
<p>F->( E)
<p>F->id
<p>OUTPUT
<p>PARSE TABLE
<p>24

    <br>
    <br>
    <br>
<p>Ex. 6: Write a program for Bottom-Up Parsing - SLR Parsing
<p>Procedure:
<p>• SLR is simple LR. It is the smallest class of grammar having few number of states.
<p>SLR is very easy to construct and is similar to LR parsing.
<p>• The only difference between SLR parser and LR(0) parser is that in LR(0) parsing
<p>table, there’s a chance of ‘shift reduced’ conflict because we are entering ‘reduce’
<p>corresponding to all terminal states.
<p>• We can solve this problem by entering ‘reduce’ corresponding to FOLLOW of LHS
<p>of production in the terminating state. This is called SLR(1) collection of items
<p>Steps for constructing the SLR parsing table :
<p>1. Writing augmented grammar
<p>2. LR(0) collection of items to be found
<p>3. Find FOLLOW of LHS of production
<p>4. Defining 2 functions:goto[list of terminals] and action[list of non-terminals] in the parsing
<p>table
<p>Sample Code
<p>import java.util.*;
<p>class SLRParser {
<p>private final List<String> grammar;
<p>private final Map<Integer, Map<String, String>> actionTable;
<p>private final Map<Integer, Map<String, Integer>> goToTable;
<p>private final Stack<Integer> stateStack;
<p>private final Stack<String> symbolStack;
<p>private final List<String> input;
<p>public SLRParser(List<String> grammar, Map<Integer, Map<String, String>>
<p>actionTable, Map<Integer, Map<String, Integer>> goToTable, List<String> input)
<p>{
<p>this.grammar = grammar;
<p>this.actionTable = actionTable;
<p>this.goToTable = goToTable;
<p>this.input = input;
<p>this.stateStack = new Stack<>();
<p>this.symbolStack = new Stack<>();
<p>}
<p>public boolean parse() {
<p>stateStack.push(0);
<p>int inputIndex = 0;
<p>while (inputIndex < input.size()) {
<p>int currentState = stateStack.peek();
<p>25
<p>String currentSymbol = input.get(inputIndex);
<p>if (actionTable.containsKey(currentState) &&
<p>actionTable.get(currentState).containsKey(currentSymbol)) {
<p>String action = actionTable.get(currentState).get(currentSymbol);
<p>if (action.startsWith("s")) {
<p>int nextState = Integer.parseInt(action.substring(1));
<p>stateStack.push(nextState);
<p>symbolStack.push(currentSymbol);
<p>inputIndex++;
<p>} else if (action.startsWith("r")) {
<p>int productionIndex = Integer.parseInt(action.substring(1));
<p>String production = grammar.get(productionIndex);
<p>String[] parts = production.split("->");
<p>String leftPart = parts[0].trim();
<p>String rightPart = parts[1].trim();
<p>int len = rightPart.split(" ").length;
<p>for (int i = 0; i < len; i++) {
<p>stateStack.pop();
<p>symbolStack.pop();
<p>}
<p>currentState = stateStack.peek();
<p>String nonTerminal = leftPart;
<p>stateStack.push(goToTable.get(currentState).get(nonTerminal));
<p>symbolStack.push(nonTerminal);
<p>} else if (action.equals("accept")) {
<p>return true;
<p>}
<p>} else {
<p>// No valid action in action table, parsing fails
<p>return false;
<p>}
<p>}
<p>// No more input symbols, parsing fails
<p>return false;
<p>}
<p>}
<p>public class Main {
<p>public static void main(String[] args) {
<p>// Example grammar
<p>List<String> grammar = Arrays.asList(
<p>26
<p>"S -> E",
<p>"E -> E + T",
<p>"E -> T",
<p>"T -> id"
<p>);
<p>// Example action table
<p>Map<Integer, Map<String, String>> actionTable = new HashMap<>();
<p>Map<String, String> action0 = new HashMap<>();
<p>action0.put("id", "s3");
<p>actionTable.put(0, action0);
<p>Map<String, String> action1 = new HashMap<>();
<p>action1.put("+", "s4");
<p>actionTable.put(1, action1);
<p>Map<String, String> action3 = new HashMap<>();
<p>action3.put("$", "accept");
<p>actionTable.put(3, action3);
<p>Map<String, String> action4 = new HashMap<>();
<p>action4.put("id", "s3");
<p>actionTable.put(4, action4);
<p>// Example go-to table
<p>Map<Integer, Map<String, Integer>> goToTable = new HashMap<>();
<p>Map<String, Integer> goTo0 = new HashMap<>();
<p>goTo0.put("E", 1);
<p>goToTable.put(0, goTo0);
<p>Map<String, Integer> goTo1 = new HashMap<>();
<p>goTo1.put("T", 2);
<p>goToTable.put(1, goTo1);
<p>// Example input
<p>List<String> input = Arrays.asList("id", "+", "id", "$");
<p>SLRParser parser = new SLRParser(grammar, actionTable, goToTable, input);
<p>boolean result = parser.parse();
<p>if (result) {
<p>System.out.println("Input string accepted by grammar.");
<p>} else {
<p>System.out.println("Input string rejected by grammar.");
<p>}
<p>}
<p>}
<p>OUTPUT:
<p>Enter input word: id*id
<p>The string is accepted
<p>27

    <br>
    <br>
    <br>
<p>Ex. 7: Introduction to basic Java - Programs in java
<p>Introduction to JAVA-
<p>• JAVA was developed by James Gosling at Sun Microsystems Inc in the year 1995 and
<p>later acquired by Oracle Corporation.
<p>• It is a simple programming language. Java makes writing, compiling, and debugging
<p>programming easy.
<p>• It helps to create reusable code and modular programs. Java is a class-based, objectoriented programming language and is designed to have as few implementation
<p>dependencies as possible.
<p>• A general-purpose programming language made for developers to Write Once Run
<p>Anywhere (WORA) that is compiled Java code can run on all platforms that support
<p>Java.
<p>• Java applications are compiled to byte code that can run on any Java Virtual Machine.
<p>The syntax of Java is similar to c/c++.
<p>• Java is known for its simplicity, robustness, and security features, making it a popular
<p>choice for enterprise-level applications.
<p>Implementation of a Java application program:
<p>• It involves a following step. They include:
<p>1. Creating the program
<p>2. Compiling the program
<p>3. Running the program
<p>• Remember that, before we begin creating the program, the Java Development Kit
<p>(JDK) must be properly installed on our system and also path will be set.
<p>Simple Java Program
<p>public class Main {
<p> public static void main(String[] args) {
<p> System.out.println("Hello World");
<p> }
<p>}
<p> Compiling the program
<p>• Save the code in Notepad as "Main.java". Open Command Prompt (cmd.exe), navigate to
<p>the directory where you saved your file, and type "javac Main.java":
<p>• To compile the program, we must run the Java compiler (javac), with the name of the
<p>source file on “command prompt” like as follows
<p>C:\Users\Your Name>javac Main.java
<p>28
<p>• This will compile your code. If there are no errors in the code, the command prompt will
<p>take you to the next line. Now, type "java Main" to run the file:
<p>C:\Users\Your Name>java Main
<p>• The output should read:
<p>Hello World
<p>Sample Code
<p>import java.util.Scanner;
<p>public class SimpleJavaProgram {
<p>public static void main(String[] args) {
<p>Scanner scanner = new Scanner(System.in);
<p>// Prompt the user to enter the first number
<p>System.out.print("Enter the first number: ");
<p>int num1 = scanner.nextInt();
<p>// Prompt the user to enter the second number
<p>System.out.print("Enter the second number: ");
<p>int num2 = scanner.nextInt();
<p>// Compute the sum of the two numbers
<p>int sum = num1 + num2;
<p>// Display the result
<p>System.out.println("The sum of " + num1 + " and " + num2 + " is: " + sum);
<p>// Close the scanner
<p>scanner.close();
<p>}
<p>}
<p>29

    <br>
    <br>
    <br>
<p>Ex. 8: Write a program to traverse syntax trees and perform action arithmetic
<p>operations
<p>Procedure:
<p>Input: Syntax tree T representing an arithmetic expression
<p>1. Define a recursive function Traverse(node), where node is a node in the syntax tree:
<p>a. If node is a leaf node containing a number:
<p>i. Return the value of the number.
<p>b. If node is an interior node representing an operator:
<p>i. Let leftValue = Traverse(leftChild), where leftChild is the left child of node.
<p>ii. Let rightValue = Traverse(rightChild), where rightChild is the right child of node.
<p>iii. Perform the arithmetic operation indicated by the operator stored in node, using
<p>leftValue and rightValue.
<p>iv. Return the result of the operation.
<p>2. Call Traverse(root), where root is the root node of the syntax tree.
<p>Sample Code
<p>class TreeNode {
<p>String value;
<p>TreeNode left;
<p>TreeNode right;
<p>TreeNode(String value) {
<p>this.value = value;
<p>this.left = null;
<p>this.right = null;
<p>}
<p>}
<p>public class SyntaxTreeTraversal {
<p>public static int traverseAndCalculate(TreeNode node) {
<p>if (node == null) {
<p>return 0;
<p>}
<p>30
<p>if (node.left == null && node.right == null) {
<p>return Integer.parseInt(node.value);
<p>}
<p>int leftValue = traverseAndCalculate(node.left);
<p>int rightValue = traverseAndCalculate(node.right);
<p>switch (node.value) {
<p>case "+":
<p>return leftValue + rightValue;
<p>case "-":
<p>return leftValue - rightValue;
<p>case "*":
<p>return leftValue * rightValue;
<p>case "/":
<p>if (rightValue == 0) {
<p>throw new ArithmeticException("Division by zero");
<p>}
<p>return leftValue / rightValue;
<p>default:
<p>throw new IllegalArgumentException("Invalid operator: " + node.value);
<p>}
<p>}
<p>public static void main(String[] args) {
<p>// Example syntax tree: 3 + (5 * 2)
<p>TreeNode root = new TreeNode("+");
<p>root.left = new TreeNode("3");
<p>root.right = new TreeNode("*");
<p>root.right.left = new TreeNode("5");
<p>root.right.right = new TreeNode("2");
<p>// Perform traversal and calculation
<p>int result = traverseAndCalculate(root);
<p>System.out.println("Result: " + result);
<p>}
<p>}
<p>Implemented a method traverse and calculate to recursively traverse the syntax tree and
<p>perform arithmetic operations. In the main method, created an example syntax tree
<p>representing the expression 3 + (5 * 2), reverse the tree, and print the result.
<p>31

    <br>
    <br>
    <br>
<p>Ex. 9: Write an Intermediate code generation for If/While
<p>Procedure
<p>• Create a method takes two strings as input: condition represents the condition of the if
<p>statement, and action represents the action to be performed if the condition is true.
<p>• Inside the generate if Code method, a StringBuilder is used to construct the code.
<p>• The condition and action strings are concatenated to form the if statement block.
<p>• Finally, the generated code is returned as a string.
<p>Can customize this code by providing different conditions and actions to generate code for
<p>different if statements. Additionally, can extend this algorithm to handle more complex if-else
<p>or nested if statements as needed.
<p>Sample Code
<p>import java.util.*;
<p>public class CodeGenerationForIf {
<p>public static void main(String[] args) {
<p>// Example input: if (x > 5) { y = x * 2; }
<p>String condition = "x > 5";
<p>String action = "y = x * 2;";
<p>// Generate code for the if statement
<p>String generatedCode = generateIfCode(condition, action);
<p>System.out.println("Generated code:");
<p>System.out.println(generatedCode);
<p>}
<p>public static String generateIfCode(String condition, String action) {
<p>StringBuilder codeBuilder = new StringBuilder();
<p>// Add the if statement
<p>32
<p>codeBuilder.append("if (").append(condition).append(") {\n");
<p>// Add the action inside the if block
<p>codeBuilder.append("\t").append(action).append("\n");
<p>// Close the if block
<p>codeBuilder.append("}");
<p>return codeBuilder.toString();
<p>}
<p>}
<p>OUTPUT:
<p>Generated code:
<p>if (x > 5) {
<p>y = x * 2;
<p>}
<p>33
    <br>
<br>
<br>
<p>Ex. 10: Code Generation Introduction to MIPS Assembly language
<p>To learn the basics of MIPS Assembly Language
<p>Introduction:
<p>• MIPS (Million Instructions Per Second) is a RISC (Reduced Instruction Set
<p>Computer)instruction set architecture developed by MIPS Technologies in the late
<p>1980s.
<p>• It is a loadstore architecture, meaning that data must be loaded into registers before
<p>it can be processed. MIPS is known for its simplicity, efficiency, and high
<p>performance.
<p>• It has been widely used in embedded systems, networking equipment, andother
<p>applications where performance and power consumption are critical.
<p>Procedure:
<p>Step 1: get value for register $a0
<p>Step 2: get value for register $a1
<p>Step 3: add values in $a0 and $a1
<p>Step 4: store result in register $v0
<p>Step 5: print value in register $v0
<p>Sample Code:
<p>.data
<p>num1: .word 10
<p>num2: .word 5
<p>.text
<p>main:
<p># load num1 into $a0
<p>lw $a0, num1
<p># load num2 into $a1
<p>lw $a1, num2
<p># add num1 and num2
<p>add $v0, $a0, $a1
<p># print result
<p>li $v0, 1 # syscall code for print_int
<p>syscall
<p># exit program
<p>li $v0, 10 # syscall code for exit
<p>syscall
<p>Output: 15
<p>34
<p>How To Run:
<p>• Open MARS MIPS Simulator.
<p>• Click "File" -> "Open" and select your MIPS assembly file.
<p>• Click "Assemble" to assemble the file.
<p>• Click "Run" to execute the program.
<p>35

    <br>
    <br>
    <br>
<p>Ex. 11: Write a program to generate machine code for a simple statement
<p>To implement a java program to convert an assembly language statement to machine
<p>Procedure
<p>• Create a byte array to store the machine code
<p>• Set the opcode for the MIPS instruction in the byte array
<p>• Set the source register for the first operand in the byte array
<p>• Set the source register for the second operand in the byte array
<p>• Set the destination register in the byte array
<p>• Set the function code for the MIPS instruction in the byte array
<p>• Write the machine code to a file
<p>Sample Code:
<p>import java.io.FileOutputStream;
<p>import java.io.IOException;
<p>public class GenerateMachineCode {
<p>public static void main(String[] args) throws IOException {
<p>// Create a byte array to store the machine code
<p>byte[] machineCode = new byte[4];
<p>// Set the opcode for the MIPS instruction in the byte array
<p>machineCode[0] = (byte) 0x0;
<p>// Set the source register for the first operand in the byte array
<p>machineCode[1] = (byte) 0x0;
<p>// Set the source register for the second operand in the byte array
<p>machineCode[2] = (byte) 0x80;
<p>// Set the destination register in the byte array
<p>machineCode[3] = (byte) 0x21;
<p>// Write the machine code to a file
<p>try (FileOutputStream fos = new FileOutputStream(“machine_code.bin”)){
<p>fos.write(machineCode);
<p>}
<p>catch (IOException e) {
<p>e.printStackTrace();
<p>}
<p>}
<p>}
<p>36
<p>Explanation:
<p>The machine code instructions for MIPS are 32 bits long. Each instruction is divided into
<p>fields, which specify the opcode, source registers, destination register, and function code.
<p>• The opcode for the add instruction is 000000. This is stored in the first byte of the
<p>machine code instruction, which is machineCode[0].
<p>• The source registers for the add instruction are $a0 and $a1. These are stored in the
<p>second and third bytes of the machine code instruction, which are machineCode[1] and
<p>machineCode[2].
<p>• The destination register for the add instruction is $v0. This is stored in the fourth byte
<p>of themachine code instruction, which is machineCode[3].
<p>• The function code for the add instruction is 000001. This is also stored in the fourth byte
<p>of the machine code instruction, which is machineCode[3].
<p>• Therefore, the machine code instruction 000000000000000010000001 translates to the
<p>MIPS assembly instruction add $v0, $a0, $a1.
<p>Here is a breakdown of the machine code instruction:
<p>000000: Opcode for the add instruction
<p>00000: Source register for the first operand ($a0)
<p>00001: Source register for the second operand ($a1)
<p>10000: Destination register ($v0)
<p>000001: Function code for the add instruction
<p>Assembly Statement: add $v0, $a0, $a1
<p>Machine Statement: 00000000000000000000000010000001
<p>How to run:
<p>javac GenerateMachineCode.java
<p>java GenerateMachineCode
<p>37

<br>
<br>
<br>
<p>Ex. 12: Write a program to generate machine code for an indexed assignment statement
<p>Procedure:
<p>Step 1: create a byte array to store the machine code
<p>Step 2: set the opcode for the MIPS instruction in the byte array
<p>Step 3: set the source register in the byte array
<p>Step 4: set the base register in the byte array
<p>Step 5: set the offset in the byte array
<p>Step 6: write the machine code to a file
<p>Sample Code:
<p>import java.io.FileOutputStream;
<p>import java.io.IOException;
<p>public class GenerateMachineCodeIndexedAssignment {
<p>public static void main(String[] args) throws IOException {
<p>// Create a byte array to store the machine code
<p>byte[] machineCode = new byte[6];
<p>// Set the opcode for the MIPS instruction in the byte array
<p>machineCode[0] = (byte) 0x2b;
<p>// Set the source register in the byte array
<p>machineCode[1] = (byte) 0x04;
<p>// Set the base register in the byte array
<p>machineCode[2] = (byte) 0x00;
<p>// Set the offset in the byte array
<p>machineCode[3] = (byte) 0x00;
<p>machineCode[4] = (byte) 0x00;
<p>machineCode[5] = (byte) 0x18;
<p>// Write the machine code to a file
<p>try (FileOutputStream fos = new FileOutputStream("machine_code.bin")) {
<p>fos.write(machineCode);
<p>} catch (IOException e) {
<p>e.printStackTrace();
<p>}
<p>}
<p>}
<p>Explanation:
<p>The first 6 bits (101011) are the opcode for the sw instruction.
<p>The next 5 bits (00000) are the source register ($v0).
<p>The next 5 bits (01000) are the base register ($a0).
<p>The next 16 bits (0000000000000100) are the offset (4).
<p>Assembly Statement: sw $v0, 4($a0)
<p>Machine Statement: 10101101000001000000000000011000

    </p>
</body>
</html>
